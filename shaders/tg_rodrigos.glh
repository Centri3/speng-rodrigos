#ifdef _FRAGMENT_ 

//-----------------------------------------------------------------------------

float HeightMapCloudsTerraAli(vec3 point) {
	float minimumStripeTwist = 1.0;

	float zones = cos(stripeZones * point.y * 1.75);
	float ang = zones * pow(max(abs(minimumStripeTwist), minimumStripeTwist), 0.6);
	vec3 twistedPoint = point;
	float coverage = cloudsCoverage * 0.5;
	float weight = 1.0;
	noiseH = 0.75;

	float offset = 0.0;

	// Compute turbulence
	twistedPoint = TurbulenceTerra(twistedPoint);

	// Compute the Coriolis effect
	float sina = sin(ang);
	float cosa = cos(ang - 10);
	twistedPoint = vec3(cosa * twistedPoint.x - sina * twistedPoint.z, twistedPoint.y, sina * twistedPoint.x + cosa * twistedPoint.z);
	twistedPoint = twistedPoint * cloudsFreq + Randomize;

	// Compute the flow-like distortion
	noiseLacunarity = 6.6;
	noiseOctaves = 0.0;

	vec3 distort = Fbm3D(twistedPoint * 2.8) * 3;
	vec3 p = twistedPoint * cloudsFreq * 75.0;
	vec3 q = p + Fbm3D(p);
	vec3 r = p + Fbm3D(q);
	float f = Fbm(r) * 4 + coverage;
	float global = saturate(f) * weight * (Fbm(twistedPoint + distort) + 0.5 * (cloudsCoverage * 0.1));

	return global;
}

//-----------------------------------------------------------------------------

float HeightMapCloudsTerraAli2(vec3 point) {
	float minimumStripeTwist = 1.0;

	float zones = cos(stripeZones * point.y * 1.75);
	float ang = zones * pow(max(abs(stripeTwist), minimumStripeTwist), 0.6);
	vec3 twistedPoint = point;
	float coverage = cloudsCoverage;
	float weight = 1.0;
	noiseH = 0.75;

	// Compute turbulence
	twistedPoint = TurbulenceTerra(twistedPoint);

	// Compute the Coriolis effect
	float sina = sin(ang);
	float cosa = cos(ang - 90);
	twistedPoint = vec3(cosa * twistedPoint.x - sina * twistedPoint.z, twistedPoint.y, sina * twistedPoint.x + cosa * twistedPoint.z);
	twistedPoint = twistedPoint * cloudsFreq + Randomize;

	// Compute the flow-like distortion
	noiseLacunarity = 6.6 - cloudsFreq;
	noiseOctaves = cloudsOctaves;

	vec3 distort = Fbm3D(twistedPoint) * 2;

	vec3 p = twistedPoint * cloudsFreq * 6.5;
	vec3 q = p + Fbm3D(p);
	vec3 r = p + Fbm3D(q);
	noiseOctaves = 0.0;
	float f = Fbm(r) * 4 + coverage;
	noiseOctaves = cloudsOctaves;
	float global = saturate(f) * weight * (Fbm(twistedPoint + distort) + cloudsCoverage);

	return global;
}

//-----------------------------------------------------------------------------

#endif
