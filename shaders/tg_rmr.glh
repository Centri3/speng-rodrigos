#include "tg_common.glh"

#ifdef _FRAGMENT_

float unwrap_or_with_sentinel(float sentinel, float optional,
                              float default_value) {
  if (optional == sentinel) {
    return default_value;
  }

  return optional;
}
#define NO_DATA -1e+38f
#define unwrap_or(optional, default_value)                                     \
  unwrap_or_with_sentinel(NO_DATA, optional, default_value)

vec3 iqTurbulence3D(vec3 point, float gain) {
  return vec3(iqTurbulence(point + vyd, gain), iqTurbulence(point + vzd, gain),
              iqTurbulence(point + vwd, gain));
}

vec3 JordanTurbulence3D(vec3 point, float gain0, float gain, float warp0,
                        float warp, float damp0, float damp, float dampScale) {
  return vec3(JordanTurbulence(point + vyd, gain0, gain, warp0, warp, damp0,
                               damp, dampScale),
              JordanTurbulence(point + vzd, gain0, gain, warp0, warp, damp0,
                               damp, dampScale),
              JordanTurbulence(point + vwd, gain0, gain, warp0, warp, damp0,
                               damp, dampScale));
}

float _VolcanoNoise(vec3 point, float globalLand, float localLand) {
  noiseLacunarity = 2.218281828459;
  noiseH = 0.5;
  noiseOffset = 0.8;

  float frequency = 150.0 * volcanoFreq;
  float density = volcanoDensity;
  float size = volcanoRadius;
  float newLand = localLand;
  float globLand = globalLand - 1.0;
  float amplitude = 2.0 * volcanoMagn;
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  vec3 rotVec = normalize(Randomize);
  vec3 binormal = normalize(vec3(
      -point.z, 0.0, point.x)); // = normalize(cross(point, vec3(0, 1, 0)));
  float distFreq = 18.361 * volcanoFreq;
  float distMagn = 0.003;

  vec3 randomize = Randomize;

  for (int i = 0; i < volcanoOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                         0.0, cos(angleX), -sin(angleX),
                         0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                         0.0, 1.0, 0.0,
                         -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                         sin(angleZ), cos(angleZ), 0.0,
                         0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;

    noiseOctaves = 4;
    vec3 p = point + distMagn * Fbm3D(point * distFreq);

    cell = inverseSF(p, frequency, cellCenter);

    float h = hash1(cell.x);
    float r = 40.0 * cell.y;
    if ((h < density) && (r < 1.0)) {
      float rnd = 48.3 * dot(cellCenter, Randomize);
      vec3 cen = normalize(cellCenter - p);
      float a = dot(p, cross(cen, binormal));
      float b = dot(cen, binormal);
      float fi1 = atan(a, b) / pi;
      float fi2 = atan(-a, -b) / pi;

      float volcano =
          globLand + amplitude * VolcanoHeightFunc(r, fi1, fi2, rnd, size);
      newLand = softPolyMax(newLand, volcano, 0.3);
    }

    if (volcanoOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      frequency *= 2.0;
      // density   *= 2.0;
      size *= 0.5;
      amplitude *= 1.2;
      distFreq *= 2.0;
      distMagn *= 0.5;
    }
  }

  return newLand;
}

vec2 _VolcanoGlowNoise(vec3 point) {
  noiseLacunarity = 2.218281828459;
  noiseH = 0.5;
  noiseOffset = 0.8;

  float frequency = 150.0 * volcanoFreq;
  float density = volcanoDensity;
  float size = volcanoRadius;
  vec2 volcTempMask = vec2(0.0, 0.0);
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  vec3 rotVec = normalize(Randomize);
  vec3 binormal = normalize(vec3(
      -point.z, 0.0, point.x)); // = normalize(cross(point, vec3(0, 1, 0)));
  float distFreq = 18.361 * volcanoFreq;
  float distMagn = 0.003;

  vec3 randomize = Randomize;

  for (int i = 0; i < volcanoOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                         0.0, cos(angleX), -sin(angleX),
                         0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                         0.0, 1.0, 0.0,
                         -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                         sin(angleZ), cos(angleZ), 0.0,
                         0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;
    noiseOctaves = 4;
    vec3 p = point + distMagn * Fbm3D(point * distFreq);

    cell = inverseSF(p, frequency, cellCenter);

    float h = hash1(cell.x);
    float r = 40.0 * cell.y;
    if ((h < density) && (r < 1.0)) {
      float rnd = 48.3 * dot(cellCenter, Randomize);
      vec3 cen = normalize(cellCenter - p);
      float a = dot(p, cross(cen, binormal));
      float b = dot(cen, binormal);
      float fi1 = atan(a, b) / pi;
      float fi2 = atan(-a, -b) / pi;

      volcTempMask =
          max(volcTempMask, vec2(1.2 * VolcanoGlowFunc(r, fi1, fi2, rnd, size),
                                 1.0 - 2.0 * r));
    }

    if (volcanoOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      frequency *= 2.0;
      size *= 0.5;
      distFreq *= 2.0;
      distMagn *= 0.5;
    }
  }

  return volcTempMask;
}

//-----------------------------------------------------------------------------

// Function // Modified rayed craters to have random brightness and random
// position
float _RayedCraterColorNoise(vec3 point, float cratFreq, float cratSqrtDensity,
                             float cratOctaves) {
  vec3 binormal = normalize(vec3(
      -point.z, 0.0, point.x)); // = normalize(cross(point, vec3(0, 1, 0)));
  vec3 rotVec = normalize(Randomize);

  // Craters roundness distortion
  noiseH = 0.5;
  noiseLacunarity = 2.218281828459;
  noiseOffset = 0.8;
  noiseOctaves = 3;
  craterDistortion = 1.0;
  craterRoundDist = 0.03;
  float shapeDist = 1.0 + 2.5 * craterRoundDist * Fbm(point * 419.54);
  float colorDist = 1.0 - 0.3 * Fbm(point * 315.16);

  float color = 0.0;
  float fi;
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  float rad;
  float radFactor = shapeDist / cratSqrtDensity;
  float fibFreq = 10.0 * cratFreq;

  heightFloor = -0.5;
  heightPeak = 0.6;
  heightRim = 1.0;
  radPeak = 0.004;
  radInner = 0.015;
  radRim = 0.03;
  radOuter = 1.3;

  vec3 randomize = Randomize;

  for (int i = 0; i < cratOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                          0.0, cos(angleX), -sin(angleX),
                          0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                          0.0, 1.0, 0.0,
                          -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                          sin(angleZ), cos(angleZ), 0.0,
                          0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;

    // cell = Cell2NoiseSphere(point, craterSphereRadius);
    ////cell = Cell2NoiseVec(point * craterSphereRadius, 1.0);
    // fi = acos(dot(binormal, normalize(cell.xyz - point))) / pi2;
    // color += vary * RayedCraterColorFunc(cell.w * radFactor, fi, 48.3 *
    // dot(cell.xyz, Randomize)); radInner  *= 0.6;

    cell = inverseSF(point, fibFreq, cellCenter);
    rad = hash1(cell.x * 743.1) * 1.4;
    fi = acos(dot(binormal, normalize(cellCenter - point))) / pi2;

    float brightness = pow(Fbm(cellCenter * 1000.0), 2.0) * 2.0 *
                       smoothstep(0.0, 0.6, craterRayedFactor);
    color += RayedCraterColorFunc(cell.y * radFactor / rad, fi,
                                  48.3 * dot(cellCenter, Randomize)) *
             brightness;

    if (cratOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      fibFreq *= 1.125;
      radFactor *= sqrt(1.125);
      radInner *= 0.9;
    }
  }

  return min(color, 1.0) * colorDist;
}

// Function // This function's only purpose is to reduce height, heightFloor and
// heightPeak by brightness.
float _RayedCraterHeightFunc(float lastlastLand, float lastLand, float height,
                             float r, float brightness) {
  // FIXME: Why does this need to be 0.0? we get crazy discontinuities if it's
  // not.
  float distHeight = 0.0; // craterDistortion * height * brightness;

  float t = 1.0 - r / radPeak;
  float peak =
      heightPeak * brightness * craterDistortion * smoothstep(0.0, 1.0, t);

  t = smoothstep(0.0, 1.0, (r - radInner) / (radRim - radInner));
  float inoutMask = t * t * t;
  float innerRim = heightRim * distHeight * smoothstep(0.0, 1.0, inoutMask);

  t = smoothstep(0.0, 1.0, (radOuter - r) / (radOuter - radRim));
  float outerRim = distHeight * mix(0.05, heightRim, t * t);

  t = saturate((1.0 - r) / (1.0 - radOuter));
  float halo = 0.05 * distHeight * t;

  // Don't apply brightness here twice to both height and heightFloor.
  return mix(lastlastLand + height * heightFloor * brightness + peak + innerRim,
             lastLand + outerRim + halo, inoutMask);
}

float _RayedCraterNoise(vec3 point, float cratMagn, float cratFreq,
                        float cratSqrtDensity, float cratOctaves) {
  vec3 rotVec = normalize(Randomize);

  // Craters roundness distortion
  noiseH = 0.5;
  noiseLacunarity = 2.218281828459;
  noiseOffset = 0.8;
  noiseOctaves = 3;
  craterDistortion = 1.0;
  craterRoundDist = 0.03;
  float shapeDist = 1.0 + 2.5 * craterRoundDist * Fbm(point * 419.54);

  radPeak = 0.004;
  radInner = 0.015;
  radRim = 0.03;
  radOuter = 0.8;

  float newLand = 0.0;
  float lastLand = 0.0;
  float lastlastLand = 0.0;
  float lastlastlastLand = 0.0;
  float amplitude = 0.1;
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  float rad;
  float radFactor = shapeDist / cratSqrtDensity;
  float fibFreq = 10.0 * cratFreq;
  vec3 randomize = Randomize;

  for (int i = 0; i < cratOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    // TODO: Make a helper function for this!
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                          0.0, cos(angleX), -sin(angleX),
                          0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                          0.0, 1.0, 0.0,
                          -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                          sin(angleZ), cos(angleZ), 0.0,
                          0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;

    lastlastlastLand = lastlastLand;
    lastlastLand = lastLand;
    lastLand = newLand;

    // cell = Cell2NoiseSphere(point, craterSphereRadius).w;
    ////cell = Cell2NoiseVec(point * craterSphereRadius, 1.0).w;
    // newLand = CraterHeightFunc(0.0, lastLand, amplitude, cell * radFactor);

    // cell    = inverseSF(point + craterRoundDist * Fbm3D(point * 2.56),
    // fibFreq);
    cell = inverseSF(point, fibFreq, cellCenter);
    rad = hash1(cell.x * 743.1) * 1.4 + 0.1;

    float brightness = pow(Fbm(cellCenter * 1000.0), 2.0) * 8.0;
    newLand = _RayedCraterHeightFunc(lastlastlastLand, lastLand, amplitude,
                                     cell.y * radFactor / rad, brightness);

    if (cratOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      // FIXME: For the first few octaves this results in very similar spots for
      // the craters. Not too noticeable but please fix me.
      fibFreq *= 1.125;
      radFactor *= sqrt(1.125);
      // FIX: Higher octave rayed craters usually have no height, so uh, let's
      // not reduce these values so quickly.
      amplitude *= 0.97;
      heightPeak *= 0.9;
      heightFloor *= 0.97;
      radInner *= 0.9;
    }
  }

  return cratMagn * newLand;
}

float HeightMapCloudsTerraAli(vec3 point) {
  float stripeTwistMult = 0.2;
  if(cloudsCoverage == 1.0) {
    stripeTwistMult = 1.4;
  }

  float zones = cos(stripeZones * point.y * 1.75);
  float ang = zones * pow(abs(stripeTwist * stripeTwistMult), 0.6);
  if (stripeTwist < 0.0) {
    ang *= -1.0;
  }
  vec3 twistedPoint = point;
  float coverage = cloudsCoverage * 0.5;
  float weight = 1.0;
  noiseH = 0.75;

  float offset = 0.0;

  // Compute turbulence
  twistedPoint = TurbulenceTerra(twistedPoint);

  // Compute the Coriolis effect
  float sina = sin(ang);
  float cosa = cos(ang);
  twistedPoint =
      vec3(cosa * twistedPoint.x - sina * twistedPoint.z, twistedPoint.y,
           sina * twistedPoint.x + cosa * twistedPoint.z);
  twistedPoint = twistedPoint * cloudsFreq + Randomize;

  // Compute the flow-like distortion
  noiseLacunarity = 6.6;
  noiseOctaves = 0.0;

  vec3 distort = Fbm3D(twistedPoint * 2.8) * 3;
  vec3 p = twistedPoint * cloudsFreq * 75.0;
  vec3 q = p + Fbm3D(p);
  vec3 r = p + Fbm3D(q);
  float f = Fbm(r) * 4 + coverage;
  float global = saturate(f) * weight *
                 (Fbm(twistedPoint + distort) + 0.5 * (cloudsCoverage * 0.1));

  return global;
}

//-----------------------------------------------------------------------------

float HeightMapCloudsTerraAli2(vec3 point) {
  float stripeTwistMult = 0.2;
  if(cloudsCoverage == 1.0) {
    stripeTwistMult = 1.4;
  }

  float zones = cos(stripeZones * point.y * 1.75);
  float ang = zones * pow(abs(stripeTwist * stripeTwistMult), 0.6);
  // HACK: Reverse stripe thingy once we reach negative stripeTwist, it's a bug
  // that it becomes white normally and I don't feel like fixing it correctly
  if (stripeTwist < 0.0) {
    ang *= -1.0;
  }
  vec3 twistedPoint = point;
  float coverage = cloudsCoverage;
  float weight = 1.0;
  noiseH = 0.75;

  // Compute turbulence
  twistedPoint = TurbulenceTerra(twistedPoint);

  // Compute the Coriolis effect
  float sina = sin(ang);
  float cosa = cos(ang);
  twistedPoint =
      vec3(cosa * twistedPoint.x - sina * twistedPoint.z, twistedPoint.y,
           sina * twistedPoint.x + cosa * twistedPoint.z);
  twistedPoint = twistedPoint * cloudsFreq + Randomize;

  // Compute the flow-like distortion
  noiseLacunarity = 6.6 - cloudsFreq;
  noiseOctaves = cloudsOctaves;

  vec3 distort = Fbm3D(twistedPoint) * 2;

  vec3 p = twistedPoint * cloudsFreq * 6.5;
  vec3 q = p + Fbm3D(p);
  vec3 r = p + Fbm3D(q);
  noiseOctaves = 0.0;
  float f = Fbm(r) * 4 + coverage;
  noiseOctaves = cloudsOctaves;
  float global =
      saturate(f) * weight * (Fbm(twistedPoint + distort) + cloudsCoverage);

  return global;
}

struct NoiseParams {
  // FIXME: IDK why we need to use floats here, but nested structs do not work.
  float octaves;
  float lacunarity;
  float h;
  float add;
  float mul;
};

struct Lacunarity {
  float inner;
};
struct Octaves {
  float inner;
};
struct H {
  float inner;
};
struct RidgeSmooth {
  float inner;
};
struct Add {
  float inner;
};
struct Mul {
  float inner;
};

Octaves DEFAULT_OCTAVES = Octaves(4.0);
Lacunarity DEFAULT_LACUNARITY = Lacunarity(2.218281828459);
H DEFAULT_H = H(0.5);

NoiseParams mk_noise(Octaves octaves, Lacunarity lacunarity, H h) {
  return NoiseParams(octaves.inner, lacunarity.inner, h.inner, 0.0f, 1.0f);
}

NoiseParams mk_noise(Octaves octaves, Lacunarity lacunarity, H h, Add add,
                     Mul mul) {
  return NoiseParams(octaves.inner, lacunarity.inner, h.inner, add.inner,
                     mul.inner);
}

#define noise_vec2(coords) vec2(Noise(coords), Noise(coords + vyd))
#define noise_vec3(coords)                                                     \
  vec3(Noise(coords), Noise(coords + vyd), Noise(coords + vzd))
#define noise_vec4(coords)                                                     \
  vec4(Noise(coords), Noise(coords + vyd), Noise(coords + vzd),                \
       Noise(coords + vwd))
#define noise_u_float(coords) Noise(coords) * 0.5 + 0.5
#define noise_u_vec3(coords) noise_vec3(coords) * 0.5 + vec3(0.5)
#define noise_u_vec4(coords) noise_vec4(coords) * 0.5 + vec4(0.5)

float noise_fbm_float(vec3 coords, NoiseParams noise) {
  float sum = 0.0f;

  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += Noise(coords) * ampl * noise.mul + noise.add;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

vec2 noise_fbm_vec2(vec3 coords, NoiseParams noise) {
  vec2 sum = vec2(0.0f);
  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += noise_vec2(coords) * ampl;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

vec3 noise_fbm_vec3(vec3 coords, NoiseParams noise) {
  vec3 sum = vec3(0.0f);
  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += noise_vec3(coords) * ampl;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

#endif
