#include "tg_common.glh"

#ifdef _FRAGMENT_

struct NoiseParams {
  // FIXME: IDK why we need to use floats here, but nested structs do not work.
  float octaves;
  float lacunarity;
  float h;
  float add;
  float mul;
};

struct Lacunarity {
  float inner;
};
struct Octaves {
  float inner;
};
struct H {
  float inner;
};
struct RidgeSmooth {
  float inner;
};
struct Add {
  float inner;
};
struct Mul {
  float inner;
};

Octaves DEFAULT_OCTAVES = Octaves(4.0);
Lacunarity DEFAULT_LACUNARITY = Lacunarity(2.218281828459);
H DEFAULT_H = H(0.5);

NoiseParams mk_noise(Octaves octaves, Lacunarity lacunarity, H h) {
  return NoiseParams(octaves.inner, lacunarity.inner, h.inner, 0.0f, 1.0f);
}

NoiseParams mk_noise(Octaves octaves, Lacunarity lacunarity, H h, Add add,
                     Mul mul) {
  return NoiseParams(octaves.inner, lacunarity.inner, h.inner, add.inner,
                     mul.inner);
}

#define noise_vec2(coords) vec2(Noise(coords), Noise(coords + vyd))
#define noise_vec3(coords)                                                     \
  vec3(Noise(coords), Noise(coords + vyd), Noise(coords + vzd))
#define noise_vec4(coords)                                                     \
  vec4(Noise(coords), Noise(coords + vyd), Noise(coords + vzd),                \
       Noise(coords + vwd))
#define noise_u_float(coords) Noise(coords) * 0.5 + 0.5
#define noise_u_vec3(coords) noise_vec3(coords) * 0.5 + vec3(0.5)
#define noise_u_vec4(coords) noise_vec4(coords) * 0.5 + vec4(0.5)

float noise_fbm_float(vec3 coords, NoiseParams noise) {
  float sum = 0.0f;

  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += Noise(coords) * ampl * noise.mul + noise.add;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

vec2 noise_fbm_vec2(vec3 coords, NoiseParams noise) {
  vec2 sum = vec2(0.0f);
  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += noise_vec2(coords) * ampl;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

vec3 noise_fbm_vec3(vec3 coords, NoiseParams noise) {
  vec3 sum = vec3(0.0f);
  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += noise_vec3(coords) * ampl;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

#endif
