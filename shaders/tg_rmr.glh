#include "tg_common.glh"

#ifdef _FRAGMENT_

const float NO_DATA = -1e+38;
float unwrap_or_with_sentinel(float optional, float default_value,
                              float sentinel) {
  if (optional == sentinel) {
    return default_value;
  } else {
    return optional;
  }
}
#define unwrap_or(optional, default_value)                                     \
  unwrap_or_with_sentinel(optional, default_value, NO_DATA)

vec3 iqTurbulence3D(vec3 point, float gain) {
  return vec3(iqTurbulence(point + vyd, gain), iqTurbulence(point + vzd, gain),
              iqTurbulence(point + vwd, gain));
}

vec3 JordanTurbulence3D(vec3 point, float gain0, float gain, float warp0,
                        float warp, float damp0, float damp, float dampScale) {
  return vec3(JordanTurbulence(point + vyd, gain0, gain, warp0, warp, damp0,
                               damp, dampScale),
              JordanTurbulence(point + vzd, gain0, gain, warp0, warp, damp0,
                               damp, dampScale),
              JordanTurbulence(point + vwd, gain0, gain, warp0, warp, damp0,
                               damp, dampScale));
}

float _VolcanoNoise(vec3 point, float globalLand, float localLand) {
  noiseLacunarity = 2.218281828459;
  noiseH = 0.5;
  noiseOffset = 0.8;

  float frequency = 150.0 * volcanoFreq;
  float density = volcanoDensity;
  float size = volcanoRadius;
  float newLand = localLand;
  float globLand = globalLand - 1.0;
  float amplitude = 2.0 * volcanoMagn;
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  vec3 rotVec = normalize(Randomize);
  vec3 binormal = normalize(vec3(
      -point.z, 0.0, point.x)); // = normalize(cross(point, vec3(0, 1, 0)));
  float distFreq = 18.361 * volcanoFreq;
  float distMagn = 0.003;

  vec3 randomize = Randomize;

  for (int i = 0; i < volcanoOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                         0.0, cos(angleX), -sin(angleX),
                         0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                         0.0, 1.0, 0.0,
                         -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                         sin(angleZ), cos(angleZ), 0.0,
                         0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;

    noiseOctaves = 4;
    vec3 p = point + distMagn * Fbm3D(point * distFreq);

    cell = inverseSF(p, frequency, cellCenter);

    float h = hash1(cell.x);
    float r = 40.0 * cell.y;
    if ((h < density) && (r < 1.0)) {
      float rnd = 48.3 * dot(cellCenter, Randomize);
      vec3 cen = normalize(cellCenter - p);
      float a = dot(p, cross(cen, binormal));
      float b = dot(cen, binormal);
      float fi1 = atan(a, b) / pi;
      float fi2 = atan(-a, -b) / pi;

      float volcano =
          globLand + amplitude * VolcanoHeightFunc(r, fi1, fi2, rnd, size);
      newLand = softPolyMax(newLand, volcano, 0.3);
    }

    if (volcanoOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      frequency *= 2.0;
      // density   *= 2.0;
      size *= 0.5;
      amplitude *= 1.2;
      distFreq *= 2.0;
      distMagn *= 0.5;
    }
  }

  return newLand;
}

vec2 _VolcanoGlowNoise(vec3 point) {
  noiseLacunarity = 2.218281828459;
  noiseH = 0.5;
  noiseOffset = 0.8;

  float frequency = 150.0 * volcanoFreq;
  float density = volcanoDensity;
  float size = volcanoRadius;
  vec2 volcTempMask = vec2(0.0, 0.0);
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  vec3 rotVec = normalize(Randomize);
  vec3 binormal = normalize(vec3(
      -point.z, 0.0, point.x)); // = normalize(cross(point, vec3(0, 1, 0)));
  float distFreq = 18.361 * volcanoFreq;
  float distMagn = 0.003;

  vec3 randomize = Randomize;

  for (int i = 0; i < volcanoOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                         0.0, cos(angleX), -sin(angleX),
                         0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                         0.0, 1.0, 0.0,
                         -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                         sin(angleZ), cos(angleZ), 0.0,
                         0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;
    noiseOctaves = 4;
    vec3 p = point + distMagn * Fbm3D(point * distFreq);

    cell = inverseSF(p, frequency, cellCenter);

    float h = hash1(cell.x);
    float r = 40.0 * cell.y;
    if ((h < density) && (r < 1.0)) {
      float rnd = 48.3 * dot(cellCenter, Randomize);
      vec3 cen = normalize(cellCenter - p);
      float a = dot(p, cross(cen, binormal));
      float b = dot(cen, binormal);
      float fi1 = atan(a, b) / pi;
      float fi2 = atan(-a, -b) / pi;

      volcTempMask =
          max(volcTempMask, vec2(1.2 * VolcanoGlowFunc(r, fi1, fi2, rnd, size),
                                 1.0 - 2.0 * r));
    }

    if (volcanoOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      frequency *= 2.0;
      size *= 0.5;
      distFreq *= 2.0;
      distMagn *= 0.5;
    }
  }

  return volcTempMask;
}

//-----------------------------------------------------------------------------

// Function // Modified rayed craters to have random brightness and random
// position
float _RayedCraterColorNoise(vec3 point, float cratFreq, float cratSqrtDensity,
                             float cratOctaves) {
  vec3 binormal = normalize(vec3(
      -point.z, 0.0, point.x)); // = normalize(cross(point, vec3(0, 1, 0)));
  vec3 rotVec = normalize(Randomize);

  // Craters roundness distortion
  noiseH = 0.5;
  noiseLacunarity = 2.218281828459;
  noiseOffset = 0.8;
  noiseOctaves = 3;
  craterDistortion = 1.0;
  craterRoundDist = 0.03;
  float shapeDist = 1.0 + 2.5 * craterRoundDist * Fbm(point * 419.54);
  float colorDist = 1.0 - 0.3 * Fbm(point * 315.16);

  float color = 0.0;
  float fi;
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  float rad;
  float radFactor = shapeDist / cratSqrtDensity;
  float fibFreq = 10.0 * cratFreq;

  heightFloor = -0.5;
  heightPeak = 0.6;
  heightRim = 1.0;
  radPeak = 0.004;
  radInner = 0.015;
  radRim = 0.03;
  radOuter = 1.3;

  vec3 randomize = Randomize;

  for (int i = 0; i < cratOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                          0.0, cos(angleX), -sin(angleX),
                          0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                          0.0, 1.0, 0.0,
                          -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                          sin(angleZ), cos(angleZ), 0.0,
                          0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;

    // cell = Cell2NoiseSphere(point, craterSphereRadius);
    ////cell = Cell2NoiseVec(point * craterSphereRadius, 1.0);
    // fi = acos(dot(binormal, normalize(cell.xyz - point))) / pi2;
    // color += vary * RayedCraterColorFunc(cell.w * radFactor, fi, 48.3 *
    // dot(cell.xyz, Randomize)); radInner  *= 0.6;

    cell = inverseSF(point, fibFreq, cellCenter);
    rad = hash1(cell.x * 743.1) * 1.4;
    fi = acos(dot(binormal, normalize(cellCenter - point))) / pi2;

    float brightness = pow(Fbm(cellCenter * 1000.0), 2.0) * 2.0 *
                       smoothstep(0.0, 0.6, craterRayedFactor);
    color += RayedCraterColorFunc(cell.y * radFactor / rad, fi,
                                  48.3 * dot(cellCenter, Randomize)) *
             brightness;

    if (cratOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      fibFreq *= 1.125;
      radFactor *= sqrt(1.125);
      radInner *= 0.9;
    }
  }

  return min(color, 1.0) * colorDist;
}

// Function // This function's only purpose is to reduce height, heightFloor and
// heightPeak by brightness.
float _RayedCraterHeightFunc(float lastlastLand, float lastLand, float height,
                             float r, float brightness) {
  // FIXME: Why does this need to be 0.0? we get crazy discontinuities if it's
  // not.
  float distHeight = 0.0; // craterDistortion * height * brightness;

  float t = 1.0 - r / radPeak;
  float peak =
      heightPeak * brightness * craterDistortion * smoothstep(0.0, 1.0, t);

  t = smoothstep(0.0, 1.0, (r - radInner) / (radRim - radInner));
  float inoutMask = t * t * t;
  float innerRim = heightRim * distHeight * smoothstep(0.0, 1.0, inoutMask);

  t = smoothstep(0.0, 1.0, (radOuter - r) / (radOuter - radRim));
  float outerRim = distHeight * mix(0.05, heightRim, t * t);

  t = saturate((1.0 - r) / (1.0 - radOuter));
  float halo = 0.05 * distHeight * t;

  // Don't apply brightness here twice to both height and heightFloor.
  return mix(lastlastLand + height * heightFloor * brightness + peak + innerRim,
             lastLand + outerRim + halo, inoutMask);
}

float _RayedCraterNoise(vec3 point, float cratMagn, float cratFreq,
                        float cratSqrtDensity, float cratOctaves) {
  vec3 rotVec = normalize(Randomize);

  // Craters roundness distortion
  noiseH = 0.5;
  noiseLacunarity = 2.218281828459;
  noiseOffset = 0.8;
  noiseOctaves = 3;
  craterDistortion = 1.0;
  craterRoundDist = 0.03;
  float shapeDist = 1.0 + 2.5 * craterRoundDist * Fbm(point * 419.54);

  radPeak = 0.004;
  radInner = 0.015;
  radRim = 0.03;
  radOuter = 0.8;

  float newLand = 0.0;
  float lastLand = 0.0;
  float lastlastLand = 0.0;
  float lastlastlastLand = 0.0;
  float amplitude = 0.1;
  vec2 cell;
  vec3 cellCenter = vec3(0.0);
  float rad;
  float radFactor = shapeDist / cratSqrtDensity;
  float fibFreq = 10.0 * cratFreq;
  vec3 randomize = Randomize;

  for (int i = 0; i < cratOctaves; i++) {
    // Hash randomize on each octave so we get a basically random result even
    // with inverseSF (which cannot be randomized). We rotate it here to give
    // the illusion of randomization!
    randomize.x = hash(randomize.x);
    randomize.y = hash(randomize.y);
    randomize.z = hash(randomize.z);

    float angleX = randomize.x * 6.283185;
    float angleY = randomize.y * 6.283185;
    float angleZ = randomize.z * 6.283185;

    // clang-format off
    // TODO: Make a helper function for this!
    mat3x3 rotX = mat3x3(1.0, 0.0, 0.0,
                          0.0, cos(angleX), -sin(angleX),
                          0.0, sin(angleX), cos(angleX));

    mat3x3 rotY = mat3x3(cos(angleY), 0.0, sin(angleY),
                          0.0, 1.0, 0.0,
                          -sin(angleY), 0.0, cos(angleY));

    mat3x3 rotZ = mat3x3(cos(angleZ), -sin(angleZ), 0.0,
                          sin(angleZ), cos(angleZ), 0.0,
                          0.0, 0.0, 1.0);
    // clang-format on

    point *= rotX;
    point *= rotY;
    point *= rotZ;

    lastlastlastLand = lastlastLand;
    lastlastLand = lastLand;
    lastLand = newLand;

    // cell = Cell2NoiseSphere(point, craterSphereRadius).w;
    ////cell = Cell2NoiseVec(point * craterSphereRadius, 1.0).w;
    // newLand = CraterHeightFunc(0.0, lastLand, amplitude, cell * radFactor);

    // cell    = inverseSF(point + craterRoundDist * Fbm3D(point * 2.56),
    // fibFreq);
    cell = inverseSF(point, fibFreq, cellCenter);
    rad = hash1(cell.x * 743.1) * 1.4 + 0.1;

    float brightness = pow(Fbm(cellCenter * 1000.0), 2.0) * 8.0;
    newLand = _RayedCraterHeightFunc(lastlastlastLand, lastLand, amplitude,
                                     cell.y * radFactor / rad, brightness);

    if (cratOctaves > 1) {
      point = Rotate(pi2 * hash1(float(i)), rotVec, point);
      // FIXME: For the first few octaves this results in very similar spots for
      // the craters. Not too noticeable but please fix me.
      fibFreq *= 1.125;
      radFactor *= sqrt(1.125);
      // FIX: Higher octave rayed craters usually have no height, so uh, let's
      // not reduce these values so quickly.
      amplitude *= 0.97;
      heightPeak *= 0.9;
      heightFloor *= 0.97;
      radInner *= 0.9;
    }
  }

  return cratMagn * newLand;
}

vec4 _GetCloudsColor(float height) {
  const float hScale = float(BIOME_CLOUD_LAYERS - 1) / float(BIOME_SURF_LAYERS);
  const float hMin = 0.0;
  const float hMax = 1.0;
  return texture(BiomeDataTable, vec2(1.0, clamp(height * hScale, hMin, hMax)));
}

vec4 _GetGasGiantCloudsColor(float height) {
  const float hScale = float(BIOME_CLOUD_LAYERS - 1) / float(BIOME_SURF_LAYERS);
  const float hMin =
      0.1; // skip top and bottom palette colors. these are used for cyclones.
  const float hMax = 1.0;
  return texture(BiomeDataTable, vec2(1.0, clamp(height * hScale, hMin, hMax)));
}

float HeightMapCloudsVenusAli(vec3 point) {
  float stripeTwistMult = 0.2;
  if (cloudsCoverage == 1.0) {
    stripeTwistMult = 1.4;
  }

  float zones = cos(stripeZones * point.y * 1.75);
  float ang = zones * pow(abs(stripeTwist * stripeTwistMult), 0.6);
  if (stripeTwist < 0.0) {
    ang *= -1.0;
  }
  vec3 twistedPoint = point;
  float coverage = cloudsCoverage * 0.5;
  float weight = 1.0;
  noiseH = 0.75;

  float offset = 0.0;

  // Compute turbulence
  twistedPoint = TurbulenceTerra(twistedPoint);

  // Compute the Coriolis effect
  float sina = -sin(ang);
  float cosa = -cos(ang);
  twistedPoint =
      vec3(cosa * twistedPoint.x - sina * twistedPoint.z, twistedPoint.y,
           sina * twistedPoint.x + cosa * twistedPoint.z);
  twistedPoint = twistedPoint * cloudsFreq + Randomize;

  // Compute the flow-like distortion
  noiseLacunarity = 6.6;
  noiseOctaves = 0.0;

  vec3 distort = Fbm3D(twistedPoint * 2.8) * 3;
  vec3 p = twistedPoint * cloudsFreq * 75.0;
  vec3 q = p + Fbm3D(p);
  vec3 r = p + Fbm3D(q);
  float f = Fbm(r) * 4 + coverage;
  float global = saturate(f) * weight *
                 (Fbm(twistedPoint + distort) + 0.5 * (cloudsCoverage * 0.1));

  return global;
}

//-----------------------------------------------------------------------------

float HeightMapCloudsVenusAli2(vec3 point) {
  float stripeTwistMult = 0.2;
  if (cloudsCoverage == 1.0) {
    stripeTwistMult = 1.4;
  }

  float zones = cos(stripeZones * point.y * 1.75);
  float ang = zones * pow(abs(stripeTwist * stripeTwistMult), 0.6);
  // HACK: Reverse stripe thingy once we reach negative stripeTwist, it's a bug
  // that it becomes white normally and I don't feel like fixing it correctly
  if (stripeTwist < 0.0) {
    ang *= -1.0;
  }
  vec3 twistedPoint = point;
  float coverage = cloudsCoverage;
  float weight = 1.0;
  noiseH = 0.75;

  // Compute turbulence
  twistedPoint = TurbulenceTerra(twistedPoint);

  // Compute the Coriolis effect
  float sina = -sin(ang);
  float cosa = -cos(ang);
  twistedPoint =
      vec3(cosa * twistedPoint.x - sina * twistedPoint.z, twistedPoint.y,
           sina * twistedPoint.x + cosa * twistedPoint.z);
  twistedPoint = twistedPoint * cloudsFreq + Randomize;

  // Compute the flow-like distortion
  noiseLacunarity = 6.6 - cloudsFreq;
  noiseOctaves = cloudsOctaves;

  vec3 distort = Fbm3D(twistedPoint) * 2;

  vec3 p = twistedPoint * cloudsFreq * 6.5;
  vec3 q = p + Fbm3D(p);
  vec3 r = p + Fbm3D(q);
  noiseOctaves = 0.0;
  float f = Fbm(r) * 4 + coverage;
  noiseOctaves = cloudsOctaves;
  float global =
      saturate(f) * weight * (Fbm(twistedPoint + distort) + cloudsCoverage);

  return global;
}

// Uses Randomize now.
vec4 _Cell2NoiseVec(vec3 p, float jitter) {
  vec3 cell = floor(p);
  vec3 offs = p - cell - vec3(0.5);
  vec3 pos;
  vec3 point = vec3(0.0);
  vec3 rnd;
  vec3 d;
  float distMin = 1.0e38;
  float dist;
  for (d.z = -1.0; d.z < 1.0; d.z += 1.0) {
    for (d.y = -1.0; d.y < 1.0; d.y += 1.0) {
      for (d.x = -1.0; d.x < 1.0; d.x += 1.0) {
        rnd =
            NoiseNearestUVec4((cell + d + Randomize * 10.0) / NOISE_TEX_3D_SIZE)
                    .xyz *
                jitter +
            d;
        pos = rnd - offs;
        dist = dot(pos, pos);
        if (distMin > dist) {
          distMin = dist;
          point = rnd;
        }
      }
    }
  }
  point = normalize(point + cell + vec3(0.5));
  return vec4(point, sqrt(distMin));
  // return vec4(point, sqrt(distMin));
}

vec4 rgb_to_xyz(vec4 color) {
  float var_R = (color.r); // R from 0.0 to 255.0
  float var_G = (color.g); // G from 0.0 to 255.0
  float var_B = (color.b); // B from 0.0 to 255.0

  if (var_R > 0.04045) {
    var_R = pow(((var_R + 0.055) / 1.055), 2.4);
  } else {
    var_R = var_R / 12.92;
  }
  if (var_G > 0.04045) {
    var_G = pow(((var_G + 0.055) / 1.055), 2.4);
  } else {
    var_G = var_G / 12.92;
  }

  if (var_B > 0.04045) {
    var_B = pow(((var_B + 0.055) / 1.055), 2.4);
  } else {
    var_B = var_B / 12.92;
  }

  var_R = var_R * 100.0;
  var_G = var_G * 100.0;
  var_B = var_B * 100.0;

  // Observer. = 2.0°, Illuminant = D65
  float X = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;
  float Y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;
  float Z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;

  return vec4(X, Y, Z, color.a);
}

vec4 xyz_to_lab(vec4 color) {

  float ref_X = 95.047; // Observer= 2.0°, Illuminant= D65
  float ref_Y = 100.000;
  float ref_Z = 108.883;

  float var_X = color.r / ref_X;
  float var_Y = color.g / ref_Y;
  float var_Z = color.b / ref_Z;

  if (var_X > 0.008856) {
    var_X = pow(var_X, (1.0 / 3.0));
  } else {
    var_X = (7.787 * var_X) + (16.0 / 116.0);
  }
  if (var_Y > 0.008856) {
    var_Y = pow(var_Y, (1.0 / 3.0));
  } else {
    var_Y = (7.787 * var_Y) + (16.0 / 116.0);
  }
  if (var_Z > 0.008856) {
    var_Z = pow(var_Z, (1.0 / 3.0));
  } else {
    var_Z = (7.787 * var_Z) + (16.0 / 116.0);
  }

  float L = (116.0 * var_Y) - 16.0;
  float a = 500.0 * (var_X - var_Y);
  float b = 200.0 * (var_Y - var_Z);

  return vec4(L, a, b, color.a);
}

vec4 lab_to_lch(vec4 color) {

  const float MPI = 3.14159265359;

  float var_H = atan(color.b, color.g); // in GLSL this is atan2

  if (var_H > 0.0) {
    var_H = (var_H / MPI) * 180.0;
  } else {
    var_H = 360.0 - (abs(var_H) / MPI) * 180.0;
  }

  float C = sqrt(pow(color.g, 2.0) + pow(color.b, 2.0));
  float H = var_H;

  return vec4(color.r, C, H, color.a);
}

vec4 lch_to_lab(vec4 color) {
  float a = cos(radians(color.b)) * color.g;
  float b = sin(radians(color.b)) * color.g;

  return vec4(color.r, a, b, color.a);
}

vec4 lab_to_xyz(vec4 color) {
  float var_Y = (color.r + 16.0) / 116.0;
  float var_X = color.g / 500.0 + var_Y;
  float var_Z = var_Y - color.b / 200.0;

  if (pow(var_Y, 3.0) > 0.008856) {
    var_Y = pow(var_Y, 3.0);
  } else {
    var_Y = (var_Y - 16.0 / 116.0) / 7.787;
  }
  if (pow(var_X, 3.0) > 0.008856) {
    var_X = pow(var_X, 3.0);
  } else {
    var_X = (var_X - 16.0 / 116.0) / 7.787;
  }
  if (pow(var_Z, 3.0) > 0.008856) {
    var_Z = pow(var_Z, 3.0);
  } else {
    var_Z = (var_Z - 16.0 / 116.0) / 7.787;
  }

  float ref_X = 95.047; // Observer= 2.0 degrees, Illuminant= D65
  float ref_Y = 100.000;
  float ref_Z = 108.883;

  float X = ref_X * var_X;
  float Y = ref_Y * var_Y;
  float Z = ref_Z * var_Z;

  return vec4(X, Y, Z, color.a);
}

vec4 xyz_to_rgb(vec4 color) {
  float var_X = color.r / 100.0; // X from 0.0 to  95.047      (Observer = 2.0
                                 // degrees, Illuminant = D65);
  float var_Y = color.g / 100.0; // Y from 0.0 to 100.000;
  float var_Z = color.b / 100.0; // Z from 0.0 to 108.883;

  float var_R = var_X * 3.2406 + var_Y * -1.5372 + var_Z * -0.4986;
  float var_G = var_X * -0.9689 + var_Y * 1.8758 + var_Z * 0.0415;
  float var_B = var_X * 0.0557 + var_Y * -0.2040 + var_Z * 1.0570;

  if (var_R > 0.0031308) {
    var_R = 1.055 * pow(var_R, (1.0 / 2.4)) - 0.055;
  } else {
    var_R = 12.92 * var_R;
  }
  if (var_G > 0.0031308) {
    var_G = 1.055 * pow(var_G, (1.0 / 2.4)) - 0.055;
  } else {
    var_G = 12.92 * var_G;
  }
  if (var_B > 0.0031308) {
    var_B = 1.055 * pow(var_B, (1.0 / 2.4)) - 0.055;
  } else {
    var_B = 12.92 * var_B;
  }

  float R = var_R;
  float G = var_G;
  float B = var_B;

  return vec4(R, G, B, color.a);
}

vec4 rgb_to_lch(vec4 color) {
  vec4 xyz = rgb_to_xyz(color);
  vec4 lab = xyz_to_lab(xyz);
  vec4 lch = lab_to_lch(lab);
  return lch;
}

vec4 lch_to_rgb(vec4 color) {
  vec4 lab = lch_to_lab(color);
  vec4 xyz = lab_to_xyz(lab);
  vec4 rgb = xyz_to_rgb(xyz);
  return rgb;
}

#define HASHED_RANDOMIZE                                                       \
  hash1(Randomize.x) * 0.3333333 + hash1(Randomize.y) * 0.3333333 +            \
      hash1(Randomize.z) * 0.3333333;

struct NoiseParams {
  // FIXME: IDK why we need to use floats here, but nested structs do not work.
  float octaves;
  float lacunarity;
  float h;
  float add;
  float mul;
};

struct Lacunarity {
  float inner;
};
struct Octaves {
  float inner;
};
struct H {
  float inner;
};
struct RidgeSmooth {
  float inner;
};
struct Add {
  float inner;
};
struct Mul {
  float inner;
};

Octaves DEFAULT_OCTAVES = Octaves(4.0);
Lacunarity DEFAULT_LACUNARITY = Lacunarity(2.218281828459);
H DEFAULT_H = H(0.5);

NoiseParams mk_noise(Octaves octaves, Lacunarity lacunarity, H h) {
  return NoiseParams(octaves.inner, lacunarity.inner, h.inner, 0.0f, 1.0f);
}

NoiseParams mk_noise(Octaves octaves, Lacunarity lacunarity, H h, Add add,
                     Mul mul) {
  return NoiseParams(octaves.inner, lacunarity.inner, h.inner, add.inner,
                     mul.inner);
}

#define noise_vec2(coords) vec2(Noise(coords), Noise(coords + vyd))
#define noise_vec3(coords)                                                     \
  vec3(Noise(coords), Noise(coords + vyd), Noise(coords + vzd))
#define noise_vec4(coords)                                                     \
  vec4(Noise(coords), Noise(coords + vyd), Noise(coords + vzd),                \
       Noise(coords + vwd))
#define noise_u_float(coords) Noise(coords) * 0.5 + 0.5
#define noise_u_vec3(coords) noise_vec3(coords) * 0.5 + vec3(0.5)
#define noise_u_vec4(coords) noise_vec4(coords) * 0.5 + vec4(0.5)

float noise_fbm_float(vec3 coords, NoiseParams noise) {
  float sum = 0.0f;

  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += Noise(coords) * ampl * noise.mul + noise.add;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

vec2 noise_fbm_vec2(vec3 coords, NoiseParams noise) {
  vec2 sum = vec2(0.0f);
  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += noise_vec2(coords) * ampl;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

vec3 noise_fbm_vec3(vec3 coords, NoiseParams noise) {
  vec3 sum = vec3(0.0f);
  float ampl = 1.0f;
  float gain = pow(noise.lacunarity, -noise.h);

  for (int i = 0; i < noise.octaves; i++) {
    sum += noise_vec3(coords) * ampl;
    ampl *= gain;
    coords *= noise.lacunarity;
  }

  return sum;
}

#endif
